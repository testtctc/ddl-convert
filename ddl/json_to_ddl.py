# encoding=utf-8


DEFAULT_TYPE = 'string'
class JsonToHiveDdl():
    """json to  hive ddl"""
    def __init__(self,jsondata):
        assert isinstance(jsondata,dict)
        self.jsondata=jsondata

    def get_keystring(self,key):
        """
        If a key name starts with an underscore the name must be escaped with
        backticks for Athena to parse it.
        """
        if str(key).startswith('_'):
            return '`{}`:'.format(key)
        return '{}:'.format(key)

    def helper_json_value_to_struct_entry(self,key, val):
        """
        If a key, val pair are nested inside another json field, this generates
        one entry in the list of struct fields generated by `json_value_to_struct`.
        One of those entries could be another struct generated by
        `json_value_to_struct` if there is another layer of nesting.
        """
        keystring = self.get_keystring(key)
        if isinstance(val, dict):
            string = keystring + self.json_value_to_struct(val)
        elif isinstance(val, list):
            string = keystring +self.get_list_type(val)
        elif isinstance(val,int):
            string = keystring + "int"
        elif isinstance(val,float):
            string = keystring + "float"
        else:
            string = keystring + DEFAULT_TYPE
        return string

    def get_list_type(self,lst):
        """Assumes that all members of a list are the same type"""
        # If there is no element in the list assume the type is string
        try:
            first_element = lst[0]
        except IndexError:
            return DEFAULT_TYPE
        # TODO: check whether then elements are the same before trying to generated
        # the inner element type here, and possibly create a new column for each Type
        # in the list.
        if not all(isinstance(element, type(first_element)) for element in lst):
            return DEFAULT_TYPE
        # TODO if the elements are structs, check whether they all have the same schema
        if isinstance(first_element, dict):
            string = self.json_value_to_struct(first_element)
        elif isinstance(first_element, list):
            string = 'array<' + self.get_list_type(first_element) + '>'
        elif isinstance(first_element, int):
            string = 'array<' + 'int' + '>'
        elif isinstance(first_element, float):
            string = 'array<' + 'float' + '>'
        else:
            string = DEFAULT_TYPE
        return string

    def json_value_to_struct(self,structkeyvals):
        """
        If a json field is a nested dict of other fields, this generates the ddl
        struct corresponding to those nested fields. It calls
        `helper_json_value_to_struct` to construct the either a `DEFAULT_TYPE entry
        or another struct. `helper_json_value_to_struct` calls this function again
        if it is another struct.
        Example: struct<field1:string, field2:string>
        Example: struct<field1:string, field2:struct<field3:string, field4:string>>
        """
        assert isinstance(structkeyvals, dict), 'structkeyvals must be a dict'
        string = 'struct<'
        ordered_dict_items = list(structkeyvals.items())
        for key, val in ordered_dict_items[:-1]:
            string += self.helper_json_value_to_struct_entry(key, val)
            string += ', '
        key, val = ordered_dict_items[-1]
        string += self.helper_json_value_to_struct_entry(key, val)
        string += '>'
        return string

    def json_field_to_string(self,key, value):
        """parse fields"""
        if isinstance(value, dict):
            return '`{}` {}'.format(key, self.json_value_to_struct(value))
        elif isinstance(value, list):
            return '`{}` '.format(key) + self.get_list_type(value)
        elif isinstance(value,int):
            return '`{}` {}'.format(key,'int')
        elif isinstance(value,float):
            string ='`{}` {}'.format(key,'float')
        else:
            return '`{}` string'.format(key)

    def to_hive_ddl(self,encoding=None):
        """entry point"""
        ddl = 'CREATE TABLE `<table_name>`(\n'
        ordered_jsondata = list(self.jsondata.items())
        for key, val in ordered_jsondata[:-1]:
            ddl += self.json_field_to_string(key, val) + ',' + '\n'
        key, val = ordered_jsondata[-1]
        ddl += self.json_field_to_string(key, val) + '\n'
        ddl += ')'
        return ddl

class JsonCommentToHiveDdl():
    """json comment to  hive ddl"""

    def __init__(self,jsondata):
        assert isinstance(jsondata,dict)
        self.jsondata=jsondata

    def to_hive_ddl(self):
        ddl = "CREATE TABLE `<table_name>` (\n{}\n)\ncomment '' \npartitoned by(logregion string,logdate string)\nstored as parquet"
        body  = ["{} string  comment '{}'".format(key,self.jsondata[key]) for key  in self.jsondata]
        return ddl.format(',\n'.join(body))